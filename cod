import smtplib
import os
import json
import xml.etree.ElementTree as ET
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import time
import threading

USER_DATA_FILE = 'user_data.json'
EMAILS_XML_FILE = 'scheduled_emails.xml'


def load_user_data():
    """Загружает данные пользователя из файла."""
    try:
        with open(USER_DATA_FILE, 'r') as file:
            data = json.load(file)
            return data['email'], data['password']
    except FileNotFoundError:
        return None, None


def save_user_data(email, password):
    """Сохраняет данные пользователя в файл."""
    data = {'email': email, 'password': password}
    with open(USER_DATA_FILE, 'w') as file:
        json.dump(data, file)


def get_user_data():
    """Получает данные пользователя, запрашивая их при необходимости."""
    email, password = load_user_data()
    if email is None:
        email = input("Введите ваш email на Яндексе: ")
        password = input("Введите ваш пароль: ")
        save_user_data(email, password)
    return email, password


def send_email(from_address, password, to_address, subject, body):
    """Отправляет email через сервер Яндекса."""
    try:
        message = MIMEMultipart()
        message['From'] = from_address
        message['To'] = to_address
        message['Subject'] = subject
        message.attach(MIMEText(body, 'plain'))

        server = smtplib.SMTP_SSL('smtp.yandex.ru', 465)
        server.login(from_address, password)
        server.sendmail(from_address, to_address, message.as_string())
        server.quit()
        print(f"Письмо успешно отправлено на {to_address}")
    except Exception as e:
        print(f"Ошибка при отправке письма: {e}")


def test_yandex_email_credentials(email, password):
    """Отправляет тестовое письмо на сам email для проверки учетных данных."""
    try:
        test_subject = "Тестовое письмо"
        test_body = "Это тестовое письмо для проверки учетных данных."
        send_email(email, password, email, test_subject, test_body)
        print("Тестовое письмо успешно отправлено.")
    except Exception as e:
        print(f"Ошибка при отправке тестового письма: {e}")


def load_email_addresses():
    """Загружает email-адреса из файла emails.txt."""
    try:
        with open('emails.txt', 'r') as file:
            emails = file.read().splitlines()
            return emails
    except FileNotFoundError:
        print("Файл emails.txt не найден.")
        return []


def create_scheduled_email():
    """Создает запланированное письмо."""
    date_str = input("Введите дату отправки (ГГГГ-ММ-ДД): ")
    while True:
        time_str = input("Введите время отправки (ЧЧ:ММ): ")
        try:
            datetime.strptime(time_str, "%H:%M")
            break
        except ValueError:
            print("Неверный формат времени. Используйте формат ЧЧ:ММ.")

    subject = input("Введите тему письма: ")
    body = input("Введите текст письма: ")
    recipients = input("Введите адреса получателей (через запятую): ")

    # Проверка наличия XML файла
    if not os.path.exists(EMAILS_XML_FILE):
        root = ET.Element("emails")
        tree = ET.ElementTree(root)
        tree.write(EMAILS_XML_FILE)

    # Загрузка XML файла
    tree = ET.parse(EMAILS_XML_FILE)
    root = tree.getroot()

    # Создание элемента email
    email_element = ET.Element("email", date=date_str, time=time_str)
    recipients_element = ET.SubElement(email_element, "recipients")
    recipients_element.text = recipients
    subject_element = ET.SubElement(email_element, "subject")
    subject_element.text = subject
    body_element = ET.SubElement(email_element, "body")
    body_element.text = body

    # Добавление элемента в XML дерево и сохранение файла
    root.append(email_element)
    tree.write(EMAILS_XML_FILE)

    print(f"Запланированная отправка создана на {date_str} {time_str}.")


def view_scheduled_emails():
    """Отображает список запланированных писем."""
    if not os.path.exists(EMAILS_XML_FILE):
        print("Запланированных отправок нет.")
        return

    tree = ET.parse(EMAILS_XML_FILE)
    root = tree.getroot()

    if not list(root):
        print("Запланированных отправок нет.")
        return

    print("Запланированные отправки:")
    for email in root.findall("email"):
        date = email.get("date")
        time = email.get("time")
        recipients = email.find("recipients").text
        subject = email.find("subject").text
        print(f"Дата: {date}, Время: {time}, Получатели: {recipients}, Тема: {subject}")


def send_scheduled_emails(email, password):
    """Отправляет запланированные письма."""
    if not os.path.exists(EMAILS_XML_FILE):
        return

    tree = ET.parse(EMAILS_XML_FILE)
    root = tree.getroot()

    for email_element in root.findall("email"):
        date_str = email_element.get("date")
        time_str = email_element.get("time")
        scheduled_time = datetime.strptime(f"{date_str} {time_str}", "%Y-%m-%d %H:%M")

        if scheduled_time <= datetime.now():
            recipients = email_element.find("recipients").text.split(",")
            subject = email_element.find("subject").text
            body = email_element.find("body").text

            for recipient in recipients:
                send_email(email, password, recipient, subject, body)

            # Удаление отправленного письма
            root.remove(email_element)
            print(f"Письмо на {date_str} {time_str} отправлено и удалено.")

    tree.write(EMAILS_XML_FILE)


def start_scheduled_email_checker(email, password):
    """Запускает цикл проверки и отправки запланированных писем в отдельном потоке."""
    while True:
        send_scheduled_emails(email, password)
        time.sleep(30)  # Пауза на 30 секунд


def main():
    """Основная функция, которая управляет отправкой писем."""
    email, password = get_user_data()

    # Запуск проверки запланированных писем в отдельном потоке
    checker_thread = threading.Thread(target=start_scheduled_email_checker, args=(email, password), daemon=True)
    checker_thread.start()

    while True:
        print("\nВыберите действие:")
        print("1. Отправить email")
        print("2. Создать запланированное письмо")
        print("3. Посмотреть активные запланированные отправки")
        print("4. Проверить учетные данные (тестовое письмо)")
        print("5. Выход")

        choice = input("Ваш выбор: ")

        if choice == '1':
            recipients = load_email_addresses()
            if recipients:
                subject = input("Введите тему письма: ")
                body = input("Введите текст письма: ")
                for recipient in recipients:
                    send_email(email, password, recipient, subject, body)
            else:
                print("Список получателей пуст. Добавьте адреса в файл emails.txt.")
        elif choice == '2':
            create_scheduled_email()
        elif choice == '3':
            view_scheduled_emails()
        elif choice == '4':
            test_yandex_email_credentials(email, password)
        elif choice == '5':
            break
        else:
            print("Неверный выбор. Пожалуйста, выберите один из предложенных вариантов.")


if __name__ == "__main__":
    main()
