import smtplib
import os
import json
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import tkinter as tk
from tkinter import messagebox, simpledialog, Listbox, MULTIPLE, Toplevel, Entry, Label, Button, Text, Scrollbar, END, \
    RIGHT, Y

# Файл для хранения данных пользователя
USER_DATA_FILE = "user_data.json"

# Файл для хранения запланированных писем
EMAILS_XML_FILE = "scheduled_emails.xml"

# Файл для хранения email адресов
EMAILS_FILE = "emails.txt"


# Функция для загрузки учетных данных пользователя
def load_user_data():
    if os.path.exists(USER_DATA_FILE):
        with open(USER_DATA_FILE, "r") as file:
            data = json.load(file)
            return data.get("email"), data.get("password")
    return None, None


# Функция для сохранения учетных данных пользователя
def save_user_data(email, password):
    data = {"email": email, "password": password}
    with open(USER_DATA_FILE, "w") as file:
        json.dump(data, file)


# Функция для отправки письма через Яндекс Почту
def send_email(recipients, subject, body):
    email, password = load_user_data()
    if not email or not password:
        print("Ошибка: учетные данные пользователя не загружены.")
        return

    msg = MIMEMultipart()
    msg['From'] = email
    msg['To'] = ", ".join(recipients)
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))

    try:
        server = smtplib.SMTP('smtp.yandex.com', 587)  # SMTP сервер для Яндекс Почты
        server.starttls()
        server.login(email, password)
        server.send_message(msg)
        server.quit()
        print(f"Письмо успешно отправлено: {subject} к {', '.join(recipients)}")
    except Exception as e:
        print(f"Ошибка при отправке письма: {str(e)}")


# Функция для создания запланированного письма
def create_scheduled_email_gui():
    def create_email():
        email_type = simpledialog.askstring("Выбор типа", "Введите тип письма (одноразовое/интервальное):")

        if email_type not in ["одноразовое", "интервальное"]:
            messagebox.showerror("Ошибка", "Неверный тип письма. Пожалуйста, введите 'одноразовое' или 'интервальное'.")
            return

        if email_type == "одноразовое":
            create_one_time_email()
        elif email_type == "интервальное":
            create_interval_email()

    def create_one_time_email():
        date_str = simpledialog.askstring("Ввод", "Введите дату отправки (ГГГГ-ММ-ДД):")
        time_str = simpledialog.askstring("Ввод", "Введите время отправки (ЧЧ:ММ):")
        subject = simpledialog.askstring("Ввод", "Введите тему письма:")

        recipient_window = Toplevel()
        recipient_window.title("Выбор получателей и текста письма")
        recipient_window.geometry("400x600")

        Label(recipient_window, text="Выберите получателей:").pack(pady=5)

        scrollbar = Scrollbar(recipient_window)
        scrollbar.pack(side=RIGHT, fill=Y)

        recipients_listbox = Listbox(recipient_window, selectmode=MULTIPLE, yscrollcommand=scrollbar.set, width=50,
                                     height=10)
        recipients_listbox.pack(pady=5)

        scrollbar.config(command=recipients_listbox.yview)

        recipients_list = load_email_addresses()
        for email in recipients_list:
            recipients_listbox.insert(END, email)

        def select_all():
            recipients_listbox.select_set(0, END)

        select_all_button = Button(recipient_window, text="Выбрать всё", command=select_all, width=25)
        select_all_button.pack(pady=5)

        def add_email():
            new_email = simpledialog.askstring("Добавить Email", "Введите новый email:")
            if new_email:
                recipients_listbox.insert(END, new_email)

        add_email_button = Button(recipient_window, text="Добавить новый email", command=add_email, width=25)
        add_email_button.pack(pady=5)

        Label(recipient_window, text="Текст письма:").pack(pady=5)

        body_text = Text(recipient_window, wrap=tk.WORD, height=10, width=40)
        body_text.pack(pady=5)

        def on_submit():
            body = body_text.get("1.0", tk.END).strip()
            selected_recipients = [recipients_listbox.get(i) for i in recipients_listbox.curselection()]

            if not selected_recipients or not body:
                messagebox.showerror("Ошибка", "Вы должны выбрать получателей и ввести текст письма.")
                return

            if not os.path.exists(EMAILS_XML_FILE):
                root = ET.Element("emails")
                tree = ET.ElementTree(root)
                tree.write(EMAILS_XML_FILE)

            tree = ET.parse(EMAILS_XML_FILE)
            root = tree.getroot()

            email_element = ET.Element("email", date=date_str, time=time_str, type="одноразовое")
            recipients_element = ET.SubElement(email_element, "recipients")
            recipients_element.text = ",".join(selected_recipients)
            subject_element = ET.SubElement(email_element, "subject")
            subject_element.text = subject
            body_element = ET.SubElement(email_element, "body")
            body_element.text = body

            root.append(email_element)
            tree.write(EMAILS_XML_FILE)

            messagebox.showinfo("Успех", f"Запланированная отправка создана на {date_str} {time_str}.")
            recipient_window.destroy()

        submit_button = Button(recipient_window, text="Подтвердить", command=on_submit, width=25)
        submit_button.pack(pady=10)

        close_button = Button(recipient_window, text="Закрыть", command=recipient_window.destroy, width=25)
        close_button.pack(pady=5)

        body_text.bind("<Control-c>", lambda event: body_text.event_generate('<<Copy>>'))
        body_text.bind("<Control-v>", lambda event: body_text.event_generate('<<Paste>>'))

        recipient_window.mainloop()

    def create_interval_email():
        def calculate_next_send_date(start_date, interval):
            if interval == "1 год":
                return start_date + timedelta(days=365)
            elif interval == "6 месяцев":
                return start_date + timedelta(days=183)
            elif interval == "1 месяц":
                return start_date + timedelta(days=30)
            elif interval == "1 неделя":
                return start_date + timedelta(days=7)
            else:
                try:
                    days = int(interval)
                    return start_date + timedelta(days=days)
                except ValueError:
                    messagebox.showerror("Ошибка", "Введите корректное количество дней.")
                    return start_date

        date_str = simpledialog.askstring("Ввод", "Введите дату отправки (ГГГГ-ММ-ДД):")
        time_str = simpledialog.askstring("Ввод", "Введите время отправки (ЧЧ:ММ):")
        subject = simpledialog.askstring("Ввод", "Введите тему письма:")

        interval_window = Toplevel()
        interval_window.title("Выбор интервала")
        interval_window.geometry("300x200")

        Label(interval_window, text="Выберите интервал:").pack(pady=5)

        interval_options = ["1 год", "6 месяцев", "1 месяц", "1 неделя", "Пользовательский"]
        interval_var = tk.StringVar(value=interval_options[0])

        interval_menu = tk.OptionMenu(interval_window, interval_var, *interval_options)
        interval_menu.pack(pady=5)

        def on_submit():
            interval = interval_var.get()
            if interval == "Пользовательский":
                interval = simpledialog.askstring("Введите интервал", "Введите интервал в днях:")

            recipient_window = Toplevel()
            recipient_window.title("Выбор получателей и текста письма")
            recipient_window.geometry("400x600")

            Label(recipient_window, text="Выберите получателей:").pack(pady=5)

            scrollbar = Scrollbar(recipient_window)
            scrollbar.pack(side=RIGHT, fill=Y)

            recipients_listbox = Listbox(recipient_window, selectmode=MULTIPLE, yscrollcommand=scrollbar.set, width=50,
                                         height=10)
            recipients_listbox.pack(pady=5)

            scrollbar.config(command=recipients_listbox.yview)

            recipients_list = load_email_addresses()
            for email in recipients_list:
                recipients_listbox.insert(END, email)

            def select_all():
                recipients_listbox.select_set(0, END)

            select_all_button = Button(recipient_window, text="Выбрать всё", command=select_all, width=25)
            select_all_button.pack(pady=5)

            def add_email():
                new_email = simpledialog.askstring("Добавить Email", "Введите новый email:")
                if new_email:
                    recipients_listbox.insert(END, new_email)

            add_email_button = Button(recipient_window, text="Добавить новый email", command=add_email, width=25)
            add_email_button.pack(pady=5)

            Label(recipient_window, text="Текст письма:").pack(pady=5)

            body_text = Text(recipient_window, wrap=tk.WORD, height=10, width=40)
            body_text.pack(pady=5)

            def on_interval_submit():
                body = body_text.get("1.0", tk.END).strip()
                selected_recipients = [recipients_listbox.get(i) for i in recipients_listbox.curselection()]

                if not selected_recipients or not body:
                    messagebox.showerror("Ошибка", "Вы должны выбрать получателей и ввести текст письма.")
                    return

                if not os.path.exists(EMAILS_XML_FILE):
                    root = ET.Element("emails")
                    tree = ET.ElementTree(root)
                    tree.write(EMAILS_XML_FILE)

                tree = ET.parse(EMAILS_XML_FILE)
                root = tree.getroot()

                start_date = datetime.strptime(f"{date_str} {time_str}", "%Y-%m-%d %H:%M")
                next_send_date = calculate_next_send_date(start_date, interval)

                while next_send_date <= datetime.now():
                    next_send_date = calculate_next_send_date(next_send_date, interval)

                email_element = ET.Element("email", date=start_date.strftime("%Y-%m-%d"), time=start_date.strftime("%H:%M"),
                                           interval=interval, type="интервальное")
                recipients_element = ET.SubElement(email_element, "recipients")
                recipients_element.text = ",".join(selected_recipients)
                subject_element = ET.SubElement(email_element, "subject")
                subject_element.text = subject
                body_element = ET.SubElement(email_element, "body")
                body_element.text = body
                next_send_element = ET.SubElement(email_element, "next_send")
                next_send_element.text = next_send_date.strftime("%Y-%m-%d %H:%M")

                root.append(email_element)
                tree.write(EMAILS_XML_FILE)

                messagebox.showinfo("Успех", f"Интервальное письмо создано. Следующая отправка: {next_send_date}.")
                recipient_window.destroy()

            submit_button = Button(recipient_window, text="Подтвердить", command=on_interval_submit, width=25)
            submit_button.pack(pady=10)

            close_button = Button(recipient_window, text="Закрыть", command=recipient_window.destroy, width=25)
            close_button.pack(pady=5)

            body_text.bind("<Control-c>", lambda event: body_text.event_generate('<<Copy>>'))
            body_text.bind("<Control-v>", lambda event: body_text.event_generate('<<Paste>>'))

            recipient_window.mainloop()

        submit_button = Button(interval_window, text="Подтвердить", command=on_submit)
        submit_button.pack(pady=10)

        interval_window.mainloop()

    create_window = Toplevel()
    create_window.title("Создание запланированного письма")
    create_window.geometry("300x200")

    Label(create_window, text="Выберите тип письма:").pack(pady=5)

    types = ["одноразовое", "интервальное"]
    type_var = tk.StringVar(value=types[0])

    type_menu = tk.OptionMenu(create_window, type_var, *types)
    type_menu.pack(pady=5)

    create_button = Button(create_window, text="Создать", command=create_email)
    create_button.pack(pady=10)

    close_button = Button(create_window, text="Закрыть", command=create_window.destroy)
    close_button.pack(pady=5)

    create_window.mainloop()


# Функция для отображения запланированных писем
def show_scheduled_emails_gui():
    def show_emails():
        if not os.path.exists(EMAILS_XML_FILE):
            messagebox.showinfo("Запланированные письма", "Нет запланированных писем.")
            return

        tree = ET.parse(EMAILS_XML_FILE)
        root = tree.getroot()

        emails = []
        for email in root.findall("email"):
            date = email.get("date")
            time = email.get("time")
            subject = email.find("subject").text
            body = email.find("body").text
            recipients = email.find("recipients").text.split(",")
            email_info = f"Дата: {date}, Время: {time}, Тема: {subject}, Получатели: {', '.join(recipients)}, Текст: {body}"
            emails.append(email_info)

        if emails:
            email_window = Toplevel()
            email_window.title("Запланированные письма")
            email_window.geometry("600x400")

            email_listbox = Listbox(email_window, width=80, height=20)
            email_listbox.pack(pady=10)

            for email in emails:
                email_listbox.insert(END, email)

            scrollbar = Scrollbar(email_window, orient="vertical", command=email_listbox.yview)
            scrollbar.pack(side=RIGHT, fill=Y)
            email_listbox.config(yscrollcommand=scrollbar.set)

            close_button = Button(email_window, text="Закрыть", command=email_window.destroy)
            close_button.pack(pady=10)

            email_window.mainloop()
        else:
            messagebox.showinfo("Запланированные письма", "Нет запланированных писем.")

    show_emails()


# Функции для управления email адресами
def load_email_addresses():
    if os.path.exists(EMAILS_FILE):
        with open(EMAILS_FILE, "r") as file:
            return [line.strip() for line in file]
    return []


def save_email_addresses(email_list):
    with open(EMAILS_FILE, "w") as file:
        file.write("\n".join(email_list))


def manage_email_addresses_gui():
    def refresh_list():
        listbox.delete(0, END)
        email_list = load_email_addresses()
        for email in email_list:
            listbox.insert(END, email)

    def add_email():
        new_email = simpledialog.askstring("Добавить Email", "Введите новый email:")
        if new_email:
            email_list = load_email_addresses()
            if new_email not in email_list:
                email_list.append(new_email)
                save_email_addresses(email_list)
                refresh_list()
            else:
                messagebox.showerror("Ошибка", "Этот email уже существует.")

    def delete_selected_emails():
        selected_indices = listbox.curselection()
        if not selected_indices:
            messagebox.showerror("Ошибка", "Выберите email для удаления.")
            return

        email_list = load_email_addresses()
        for index in reversed(selected_indices):
            email_list.pop(index)
        save_email_addresses(email_list)
        refresh_list()

    def edit_selected_email():
        selected_indices = listbox.curselection()
        if len(selected_indices) != 1:
            messagebox.showerror("Ошибка", "Выберите один email для редактирования.")
            return

        index = selected_indices[0]
        old_email = listbox.get(index)
        new_email = simpledialog.askstring("Редактировать Email", "Введите новый email:", initialvalue=old_email)
        if new_email:
            email_list = load_email_addresses()
            if new_email not in email_list:
                email_list[index] = new_email
                save_email_addresses(email_list)
                refresh_list()
            else:
                messagebox.showerror("Ошибка", "Этот email уже существует.")

    manage_window = Toplevel()
    manage_window.title("Управление Email Адресами")
    manage_window.geometry("400x300")

    listbox = Listbox(manage_window, selectmode=MULTIPLE, width=50, height=15)
    listbox.pack(pady=10)

    scrollbar = Scrollbar(manage_window, orient="vertical", command=listbox.yview)
    scrollbar.pack(side=RIGHT, fill=Y)
    listbox.config(yscrollcommand=scrollbar.set)

    Button(manage_window, text="Обновить", command=refresh_list).pack(pady=5)
    Button(manage_window, text="Добавить Email", command=add_email).pack(pady=5)
    Button(manage_window, text="Удалить выбранные", command=delete_selected_emails).pack(pady=5)
    Button(manage_window, text="Редактировать выбранный", command=edit_selected_email).pack(pady=5)

    refresh_list()


# Функция для редактирования учетных данных пользователя
def edit_user_data_gui():
    def save_changes():
        email = email_entry.get()
        password = password_entry.get()
        save_user_data(email, password)
        messagebox.showinfo("Успех", "Учетные данные успешно сохранены.")
        edit_window.destroy()

    edit_window = Toplevel()
    edit_window.title("Редактирование учетных данных")
    edit_window.geometry("300x200")

    Label(edit_window, text="Email:").pack(pady=5)
    email_entry = Entry(edit_window, width=30)
    email_entry.pack(pady=5)

    Label(edit_window, text="Пароль:").pack(pady=5)
    password_entry = Entry(edit_window, show="*", width=30)
    password_entry.pack(pady=5)

    Button(edit_window, text="Сохранить", command=save_changes).pack(pady=10)
    Button(edit_window, text="Закрыть", command=edit_window.destroy).pack(pady=5)

    email, password = load_user_data()
    if email:
        email_entry.insert(0, email)
    if password:
        password_entry.insert(0, password)

    edit_window.mainloop()


# Основное графическое окно
def main_gui():
    root = tk.Tk()
    root.title("Email Scheduler")
    root.geometry("400x300")

    Button(root, text="Создать запланированное письмо", command=create_scheduled_email_gui).pack(pady=10)
    Button(root, text="Просмотреть запланированные письма", command=show_scheduled_emails_gui).pack(pady=10)
    Button(root, text="Управление Email Адресами", command=manage_email_addresses_gui).pack(pady=10)
    Button(root, text="Редактировать учетные данные", command=edit_user_data_gui).pack(pady=10)

    root.mainloop()


if __name__ == "__main__":
    main_gui()
